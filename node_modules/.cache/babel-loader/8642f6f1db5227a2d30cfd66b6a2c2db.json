{"ast":null,"code":"import path from 'node:path';\nimport fs, { promises as fsPromises } from 'node:fs';\nimport writeFileAtomic from 'write-file-atomic';\nimport sortKeys from 'sort-keys';\nimport detectIndent from 'detect-indent';\nimport isPlainObj from 'is-plain-obj';\n\nconst init = (function_, filePath, data, options) => {\n  if (!filePath) {\n    throw new TypeError('Expected a filepath');\n  }\n\n  if (data === undefined) {\n    throw new TypeError('Expected data to stringify');\n  }\n\n  options = {\n    indent: '\\t',\n    sortKeys: false,\n    ...options\n  };\n\n  if (options.sortKeys && isPlainObj(data)) {\n    data = sortKeys(data, {\n      deep: true,\n      compare: typeof options.sortKeys === 'function' ? options.sortKeys : undefined\n    });\n  }\n\n  return function_(filePath, data, options);\n};\n\nconst main = async (filePath, data, options) => {\n  let {\n    indent\n  } = options;\n  let trailingNewline = '\\n';\n\n  try {\n    const file = await fsPromises.readFile(filePath, 'utf8');\n\n    if (!file.endsWith('\\n')) {\n      trailingNewline = '';\n    }\n\n    if (options.detectIndent) {\n      indent = detectIndent(file).indent;\n    }\n  } catch (error) {\n    if (error.code !== 'ENOENT') {\n      throw error;\n    }\n  }\n\n  const json = JSON.stringify(data, options.replacer, indent);\n  return writeFileAtomic(filePath, `${json}${trailingNewline}`, {\n    mode: options.mode,\n    chown: false\n  });\n};\n\nconst mainSync = (filePath, data, options) => {\n  let {\n    indent\n  } = options;\n  let trailingNewline = '\\n';\n\n  try {\n    const file = fs.readFileSync(filePath, 'utf8');\n\n    if (!file.endsWith('\\n')) {\n      trailingNewline = '';\n    }\n\n    if (options.detectIndent) {\n      indent = detectIndent(file).indent;\n    }\n  } catch (error) {\n    if (error.code !== 'ENOENT') {\n      throw error;\n    }\n  }\n\n  const json = JSON.stringify(data, options.replacer, indent);\n  return writeFileAtomic.sync(filePath, `${json}${trailingNewline}`, {\n    mode: options.mode,\n    chown: false\n  });\n};\n\nexport async function writeJsonFile(filePath, data, options) {\n  await fsPromises.mkdir(path.dirname(filePath), {\n    recursive: true\n  });\n  await init(main, filePath, data, options);\n}\nexport function writeJsonFileSync(filePath, data, options) {\n  fs.mkdirSync(path.dirname(filePath), {\n    recursive: true\n  });\n  init(mainSync, filePath, data, options);\n}","map":{"version":3,"names":["path","fs","promises","fsPromises","writeFileAtomic","sortKeys","detectIndent","isPlainObj","init","function_","filePath","data","options","TypeError","undefined","indent","deep","compare","main","trailingNewline","file","readFile","endsWith","error","code","json","JSON","stringify","replacer","mode","chown","mainSync","readFileSync","sync","writeJsonFile","mkdir","dirname","recursive","writeJsonFileSync","mkdirSync"],"sources":["/home/joduss/Documents/Programmation/react/node_modules/write-json-file/index.js"],"sourcesContent":["import path from 'node:path';\nimport fs, {promises as fsPromises} from 'node:fs';\nimport writeFileAtomic from 'write-file-atomic';\nimport sortKeys from 'sort-keys';\nimport detectIndent from 'detect-indent';\nimport isPlainObj from 'is-plain-obj';\n\nconst init = (function_, filePath, data, options) => {\n\tif (!filePath) {\n\t\tthrow new TypeError('Expected a filepath');\n\t}\n\n\tif (data === undefined) {\n\t\tthrow new TypeError('Expected data to stringify');\n\t}\n\n\toptions = {\n\t\tindent: '\\t',\n\t\tsortKeys: false,\n\t\t...options,\n\t};\n\n\tif (options.sortKeys && isPlainObj(data)) {\n\t\tdata = sortKeys(data, {\n\t\t\tdeep: true,\n\t\t\tcompare: typeof options.sortKeys === 'function' ? options.sortKeys : undefined,\n\t\t});\n\t}\n\n\treturn function_(filePath, data, options);\n};\n\nconst main = async (filePath, data, options) => {\n\tlet {indent} = options;\n\tlet trailingNewline = '\\n';\n\ttry {\n\t\tconst file = await fsPromises.readFile(filePath, 'utf8');\n\t\tif (!file.endsWith('\\n')) {\n\t\t\ttrailingNewline = '';\n\t\t}\n\n\t\tif (options.detectIndent) {\n\t\t\tindent = detectIndent(file).indent;\n\t\t}\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tconst json = JSON.stringify(data, options.replacer, indent);\n\n\treturn writeFileAtomic(filePath, `${json}${trailingNewline}`, {mode: options.mode, chown: false});\n};\n\nconst mainSync = (filePath, data, options) => {\n\tlet {indent} = options;\n\tlet trailingNewline = '\\n';\n\ttry {\n\t\tconst file = fs.readFileSync(filePath, 'utf8');\n\t\tif (!file.endsWith('\\n')) {\n\t\t\ttrailingNewline = '';\n\t\t}\n\n\t\tif (options.detectIndent) {\n\t\t\tindent = detectIndent(file).indent;\n\t\t}\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tconst json = JSON.stringify(data, options.replacer, indent);\n\n\treturn writeFileAtomic.sync(filePath, `${json}${trailingNewline}`, {mode: options.mode, chown: false});\n};\n\nexport async function writeJsonFile(filePath, data, options) {\n\tawait fsPromises.mkdir(path.dirname(filePath), {recursive: true});\n\tawait init(main, filePath, data, options);\n}\n\nexport function writeJsonFileSync(filePath, data, options) {\n\tfs.mkdirSync(path.dirname(filePath), {recursive: true});\n\tinit(mainSync, filePath, data, options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}